# 7-malloc

To prevent compaction, I implemented a coalesce() helper function, which I call in mm_free() every time a block is freed. Essentially, with this function, I check the ‘prev’ and ‘next’ blocks adjacent to the one currently being freed. If either, or both, of them are freed, then I combine them with the current block being freed, which, for the most part, takes care of the existence of small free blocks by combining adjacent ones in the freed list. Another way I prevent compaction is within my mm_malloc() function. If a block large enough to allocate memory to is found, I split if (the size of the current block - size of the block to malloc) is larger than MINBLOCKSIZE. I then insert the leftover memory into the free list. Lastly, although this does create a few leftover blocks (if splitting occurs), within my mm_realloc() function, I take care of this issue. In checking the adjacent block to the one that is passed in (the ‘next block’) to see if it is large enough to reallocate memory to, I prevent any small blocks from being scattered around the heap. If the next block is not large enough to reallocate space to, then I call mm_malloc(), but free the current pointer that is passed in first, which then, again, coalesces any adjacent blocks. Due to a combination of all these calls, I prevent compaction in the heap. 

For this reason, when implementing my mm_realloc(), I essentially made sure to check the following three conditions: (1) first, if the requested size is smaller than the pointer’s size (which, in that case, I’d split and reallocate the memory), (2) if the next block is free, and if the size of the next block as well as the current block’s pointer is larger than the requested size (which, then, I’d extend the size of the original block), and (3) lastly, if none of the two mentioned conditions are true, I then search through the free list to find a block that is large enough. In regards to the third condition, after freeing the current block, I call mm_malloc(), and then memcpy the bytes of data over to the block it returns.

After running ‘./mdriver’, it outputted that I had a throughput score of 100. This is because of the optimizations in my program in regards to how I split and handle memory allocation. I only call mem_sbrk three times in my program: once in mm_malloc() (only if absolutely necessary), and twice when I allocate the prologue and epilogue. Within my realloc function, I also optimize my program by minimizing the amount of times mm_malloc() is called (and, consequently, mem_sbrk) by checking if the next block is unallocated, as well as checking if the requested size is smaller than that of the current pointer block. Essentially, I optimize the splitting condition by checking if the requested input size is less than, or equal to, the size of the original ptr block divided by two. Additionally, I check the next block to see if it is unallocated (and thus big enough) to reallocate space to, and if not, I free the current input block (and consequently, coalesce) before calling mm_malloc to retrieve a sufficiently large block. Since I do not call mem_sbrk often, this has allowed for me to have such a high throughput score.

I used to have an only issue with my program is in regards to it not having the optimal utilization for the last realloc() trace. I had a score of 35.2, which is still quite low. This was likely because there were a few small blocks in my heap, since I do not call mem_sbrk frequently in my program. However, I was able to fix this by optimizing the condition for splitting within my mm_malloc() function. I used to check if the inputted size subtracted from the size of the current block was greater than the MINBLOCKSIZE. However, I realized this was likely creating small, scattered blocks throughout the heap. Thus, I changed this condition by multiplying 16 to the MINBLOCKSIZE to increase it. This increased my util score for that trace to 46, allowing me to pass the trace. 
