# 7-malloc

To prevent compaction, I implemented a coalesce() helper function, which I call in mm_free() every time a block is freed. Essentially, with this function, I check the ‘prev’ and ‘next’ blocks adjacent to the one currently being freed. If either, or both, of them are freed, then I combine them with the current block being freed, which, for the most part, takes care of the existence of small free blocks by combining adjacent ones in the freed list. Another way I prevent compaction is within my mm_malloc() function. If a block large enough to allocate memory to is found, I split if (the size of the current block - size of the block to malloc) is larger than MINBLOCKSIZE. I then insert the leftover memory into the free list. Lastly, although this does create a few leftover blocks (if splitting occurs), within my mm_realloc() function, I take care of this issue. In checking the adjacent block to the one that is passed in (the ‘next block’) to see if it is large enough to reallocate memory to, I prevent any small blocks from being scattered around the heap. If the next block is not large enough to reallocate space to, then I call mm_malloc(), but free the current pointer that is passed in first, which then, again, coalesces any adjacent blocks. Due to a combination of all these calls, I prevent compaction in the heap. 

For this reason, when implementing my mm_realloc(), I essentially made sure to check the following three conditions: (1) first, if the requested size is smaller than the pointer’s size (which, in that case, I’d split and reallocate the memory), (2) if the next block is free, and if the size of the next block as well as the current block’s pointer is larger than the requested size (which, then, I’d extend the size of the original block), and (3) lastly, if none of the two mentioned conditions are true, I then search through the free list to find a block that is large enough. In regards to the third condition, after freeing the current block, I call mm_malloc(), and then memcpy the bytes of data over to the block it returns.

After running ‘./mdriver’, it outputted that I had a throughput score of 100. This is because of the optimizations in my program in regards to how I split and handle memory allocation. I only call memcpy three times in my program: once in mm_malloc() (only if absolutely necessary), and twice when I allocate the prologue and epilogue. Within my realloc function, I optimize the splitting condition by checking if the requested input size is less than, or equal to, the size of the original ptr block divided by two. In my realloc function, I check the next block to see if it is unallocated (and thus big enough) to reallocate space to, and if not, I free the current input block (and consequently, coalesce) before calling mm_malloc to retrieve a sufficiently large block. Since I do not call mem_sbrk often, this has allowed for me to have such a high throughput score. However, as a result of this, I have a low space utilization score for the last realloc() trace. 

The only issue with my program is in regards to it not having the optimal utilization for the last realloc() trace. I have a score of 35.2, which is still quite low. This is likely because there are a few small blocks in my heap, since I do not call mem_sbrk frequently in my program. A possible way to have this fixed would be to also check (in mm_realloc()) the ‘prev’ block to see if it is unallocated and thus large enough. However, for the most part, all other traces have optimal space utilization. 
